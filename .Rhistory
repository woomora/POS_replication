modelsummary,   # Model summaries and visualizations
readxl,         # Excel file reading
ggnewscale,     # Add multiple scales to ggplot2
ggthemes,       # Additional ggplot2 themes
pracma,         # Practical mathematical functions
tsibble,        # Time series data frame structure
feasts,         # Time series decomposition
fabletools,     # Time series forecasting tools
lpirfs,         # Local projection impulse response functions
zoo,            # Time series objects
binsreg,        # Binned scatterplots for regression analysis
knitr,          # Dynamic report generation in R
httr,           # Tools for working with HTTP, useful for API calls and web requests
readxl          # Read Excel files into R
)
# Packages in GitHub
pacman::p_load_gh(
"synth-inference/synthdid",     # Difference-in-differences with synthetic control
"vdeminstitute/vdemdata"        # Loads the V-Dem dataset, providing data on democracy indicators across the world
)
# Set working directory to the appropriate project path
path <- getwd()
# Define and set a clean theme for all plots using ggthemes and additional customization
theme_clean <-
ggthemes::theme_clean() +
theme(
legend.position = "bottom",
plot.background = element_rect(fill = "white", color = NA), # Set plot background to white
panel.background = element_rect(fill = "white", color = NA), # Set panel background to white
legend.background = element_rect(fill = "white", color = NA), # Set legend background to white
)
theme_set(theme_clean)
# Define a custom color for plotting (used later in your plots)
color4t <- '#a83232'
# Key political and event-related dates used for analysis
amlo_vic_date <- ymd("2018-07-01")      # AMLO victory date
amlo_vic_quarter <- 2018.3              # AMLO victory quarter
naim_ref_anouncement <- ymd("2018-08-21")  # Announcement date of NAIM referendum
naim_canc_date <- ymd("2018-10-29")        # NAIM cancelation date
naim_canc_quarter <- 2018.4                # NAIM cancelation quarter
amlo_gov_date <- ymd("2018-12-01")         # AMLO government start date
amlo_gov_quarter <- 2018.4                 # AMLO government start quarter
covid_date <- ymd("2020-02-01")            # Start of COVID-19 pandemic
covid_quarter <- 2020.1                    # COVID-19 quarter
# Set the system locale to English (US) to prevent issues with special characters
Sys.setlocale("LC_ALL", "en_US.UTF-8")
# Source custom functions for synthetic control analysis from a separate script
source("scripts/POS_functions.R")
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# ---- Data ----
# ------------------------------------------------------------------------------
# Check "scripts/POS_data.R" to see the construction of derived data from source
source("scripts/POS_data.R")
# ------------------------------------------------------------------------------
# ---- Exhibits ----
# ------------------------------------------------------------------------------
# Figure 1: Synthetic DID on exchange rate around NAIMâ€™s cancellation ----
source("scripts/exhibits/POS_Fig1.R")
sessionInfo()
run_scm_analysis <- function(component, log_transform = TRUE, output_name) {
# ------------------------------------------------------------------------------
# Data Loading and Preparation
# ------------------------------------------------------------------------------
foo <- posq |>
filter(countrycode %in% c("ARG", "BRA", "CHL", "COL", "CRI", "HND", "ECU", "MEX", "USA", "CAN")) |>
filter(year >= 2013) |>
filter(year_quarter < yearquarter("2020 Q1")) |>
select(countrycode, year_quarter, all_of(component), int_rate, ex_rate, naim) |>  # Selecting component dynamically
distinct() |>
mutate(
across(all_of(component), ~ log(.x)),  # Log-transform component
ex_rate = log(ex_rate),   # Log-transform exchange rate
int_rate = log(int_rate)  # Log-transform interest rate
)
# ------------------------------------------------------------------------------
# Residualization of the component (controlling for interest and exchange rates)
# ------------------------------------------------------------------------------
component_res <- feols(as.formula(paste0(component, " ~ ex_rate + int_rate")), foo)  # Dynamically create formula
foo <- foo |> mutate(!!paste0(component, "_res") := residuals(component_res))  # Store residualized component
# ------------------------------------------------------------------------------
# Defining Pre- and Post-Treatment Periods for SCM
# ------------------------------------------------------------------------------
period.labels <- as.character(levels(factor(foo$year_quarter)))  # Period labels for x-axis
period <- yearquarter(levels(factor(foo$year_quarter)))          # Time variable as year-quarter
time.tr <- yearquarter("2018 Q4")                                # Treatment period (NAIM cancellation)
# Pre-treatment and post-treatment periods
period.pre <- period[-c(match(time.tr, period):length(period))]   # Pre-treatment period
period.post <- period[c(match(time.tr, period):length(period))]   # Post-treatment period
# Add time-to-treatment variable
foo <- foo |>
group_by(countrycode) |>
mutate(
time_to_treat_naim = c(seq(-length(period.pre), -1), seq(0, length(period.post) - 1))  # Relative time to treatment
) |>
ungroup()
period <- as.numeric(levels(factor(foo$time_to_treat_naim)))  # Convert period to numeric
# ------------------------------------------------------------------------------
# Data Preparation for SCM
# ------------------------------------------------------------------------------
# Set options for data preparation
time.tr <- 0
id.var      <- "countrycode"                             # ID variable
time.var    <- "time_to_treat_naim"                                # Time variable
period.pre  <- period[-c(match(time.tr, period):length(period))]   # Pre-treatment period
period.post <- period[c(match(time.tr, period):length(period))]                          # Post-treatment period
unit.tr     <- "MEX"                                      # Treated unit (in terms of id.var)
unit.co     <- unique(foo$countrycode)[-match( "MEX", unique(foo$countrycode))]                    # Donors pool
outcome.var <- paste0(component, "_res")                                 # Outcome variable
cov.adj     <- NULL #list(c("constant"))     # Covariates for adjustment
features    <- NULL #,                                  # No features other than outcome
constant    <- T                                # Constant term
report.missing <- FALSE                              # To check where missing values are
cointegrated.data <- TRUE                            # Belief that the data are cointegrated
w.constr <- list(name = "lasso")     # Simplex-type constraint set
df  <-   scdata(df = foo, id.var = id.var, time.var = time.var, outcome.var = outcome.var,
period.pre = period.pre, period.post = period.post,
unit.tr = unit.tr, unit.co = unit.co, cov.adj = cov.adj, features = features,
constant = constant, cointegrated.data = cointegrated.data)
# ------------------------------------------------------------------------------
# Estimation using SCM
# ------------------------------------------------------------------------------
set.seed(1234)
model <- scpi(
w.constr = list(name = "lasso"), data = df, u.order = 1, u.lags = 0, u.sigma = "HC1",
u.missp = TRUE, sims = 1000, e.order = 0, e.lags = 1, e.method = "all", cores = parallel::detectCores(),
u.alpha = 0.05, e.alpha = 0.1, rho = NULL, rho.max = 1
)
# Save SCM estimates and inference
scpi_estimates <- sc_est(model, paste0(component, "_res"), period, period.labels)
write_csv(scpi_estimates, paste0("results/FigC2/", output_name, "_scpi_estimates.csv"))
scpi_inference <- sc_inf(model, post_tr = period.post, period_labels = period.labels)
write_csv(scpi_inference, paste0("results/FigC2/", output_name, "_scpi_inference.csv"))
weights <- tibble(
weights = round(model$est.results$w, 4),
country = str_remove(names(model$est.results$w), str_c(unit.tr, "."))
)
write_csv(weights, paste0("results/FigC2/", output_name, "_scpi_weights.csv"))
# ------------------------------------------------------------------------------
# Plotting ATT (Average Treatment Effect) with Prediction Intervals
# ------------------------------------------------------------------------------
# MSE
mse <-
scpi_estimates |>
filter(name == "diff") |>
mutate(
mse = value^2,
)
mse_pre <- (mse |> filter(time_to_treat < 0) |> summarise(mse = sum(mse)))$mse
mse_post <- (mse |> filter(time_to_treat >= 0) |> summarise(mse = sum(mse)))$mse
rmse_pre <- sqrt(mse_pre/(nrow(mse |> filter(time_to_treat < 0)) + 1))
rmse_post <- sqrt(mse_post/(nrow(mse |> filter(time_to_treat >= 0)) + 1))
ratio <- rmse_post/rmse_pre
inference_2 <- scpi_inference |>
filter(time_to_treat != -1) |>
left_join(scpi_estimates |> filter(name == "obs") |> select(time_to_treat, value)) |>
mutate(
lci_ins = value - lci_ins, uci_ins = value - uci_ins,
lci_ofs = value - lci_ofs, uci_ofs = value - uci_ofs
) |>
select(-value)
scpi_estimates |>
filter(name == "diff") |>
ggplot() +
geom_hline(yintercept = 0) +
geom_vline(xintercept = 0) +
scale_x_continuous(breaks = c(seq(-70, 0, 2), seq(0, 4, 2))) +
labs(x = "Relative time to treatment (quarters)", y = "ATT", color = "", fill = "") +
theme(axis.text.x = element_text(size = 8, angle = 0)) +
geom_ribbon(data = inference_2, alpha = 0.25, aes(x = time_to_treat, ymin = lci_ins, ymax = uci_ins, fill = "95% In-sample PI")) +
geom_ribbon(data = inference_2, alpha = 0.5, aes(x = time_to_treat, ymin = lci_ofs, ymax = uci_ofs, fill = "90% Out-of-sample PI")) +
scale_fill_manual(values = c("grey", "grey70")) +
geom_line(aes(time_to_treat, value), color = color4t) +
annotate("label", x = 0, y = Inf, vjust = 0, size = 2, hjust = 1.1, color = "black", label = str_c("RMSPE: ", round(rmse_pre, 3))) +
annotate("label", x = 0, y = Inf, vjust = 0, size = 2, hjust = -0.1, color = "black", label = str_c("RMSPE: ", round(rmse_post, 3))) +
coord_cartesian(clip = "off") +
theme(plot.margin = unit(c(1.25, 1, 1, 1), "lines"))
# Save the plot as a PNG file
ggsave(paste0("results/FigC2/", output_name, ".png"), dpi = 300, width = 7.4, height = 4.8)
}
run_scm_analysis <- function(component, log_transform = TRUE, output_name) {
# ------------------------------------------------------------------------------
# Data Loading and Preparation
# ------------------------------------------------------------------------------
foo <- posq |>
filter(countrycode %in% c("ARG", "BRA", "CHL", "COL", "CRI", "HND", "ECU", "MEX", "USA", "CAN")) |>
filter(year >= 2013) |>
filter(year_quarter < yearquarter("2020 Q1")) |>
select(countrycode, year_quarter, all_of(component), int_rate, ex_rate, naim) |>  # Selecting component dynamically
distinct() |>
mutate(
across(all_of(component), ~ log(.x)),  # Log-transform component
ex_rate = log(ex_rate),   # Log-transform exchange rate
int_rate = log(int_rate)  # Log-transform interest rate
)
# ------------------------------------------------------------------------------
# Residualization of the component (controlling for interest and exchange rates)
# ------------------------------------------------------------------------------
component_res <- feols(as.formula(paste0(component, " ~ ex_rate + int_rate")), foo)  # Dynamically create formula
foo <- foo |> mutate(!!paste0(component, "_res") := residuals(component_res))  # Store residualized component
# ------------------------------------------------------------------------------
# Defining Pre- and Post-Treatment Periods for SCM
# ------------------------------------------------------------------------------
period.labels <- as.character(levels(factor(foo$year_quarter)))  # Period labels for x-axis
period <- yearquarter(levels(factor(foo$year_quarter)))          # Time variable as year-quarter
time.tr <- yearquarter("2018 Q4")                                # Treatment period (NAIM cancellation)
# Pre-treatment and post-treatment periods
period.pre <- period[-c(match(time.tr, period):length(period))]   # Pre-treatment period
period.post <- period[c(match(time.tr, period):length(period))]   # Post-treatment period
# Add time-to-treatment variable
foo <- foo |>
group_by(countrycode) |>
mutate(
time_to_treat_naim = c(seq(-length(period.pre), -1), seq(0, length(period.post) - 1))  # Relative time to treatment
) |>
ungroup()
period <- as.numeric(levels(factor(foo$time_to_treat_naim)))  # Convert period to numeric
# ------------------------------------------------------------------------------
# Data Preparation for SCM
# ------------------------------------------------------------------------------
# Set options for data preparation
time.tr <- 0
id.var      <- "countrycode"                             # ID variable
time.var    <- "time_to_treat_naim"                                # Time variable
period.pre  <- period[-c(match(time.tr, period):length(period))]   # Pre-treatment period
period.post <- period[c(match(time.tr, period):length(period))]                          # Post-treatment period
unit.tr     <- "MEX"                                      # Treated unit (in terms of id.var)
unit.co     <- unique(foo$countrycode)[-match( "MEX", unique(foo$countrycode))]                    # Donors pool
outcome.var <- paste0(component, "_res")                                 # Outcome variable
cov.adj     <- NULL #list(c("constant"))     # Covariates for adjustment
features    <- NULL #,                                  # No features other than outcome
constant    <- T                                # Constant term
report.missing <- FALSE                              # To check where missing values are
cointegrated.data <- TRUE                            # Belief that the data are cointegrated
w.constr <- list(name = "lasso")     # Simplex-type constraint set
df  <-   scdata(df = foo, id.var = id.var, time.var = time.var, outcome.var = outcome.var,
period.pre = period.pre, period.post = period.post,
unit.tr = unit.tr, unit.co = unit.co, cov.adj = cov.adj, features = features,
constant = constant, cointegrated.data = cointegrated.data)
# ------------------------------------------------------------------------------
# Estimation using SCM
# ------------------------------------------------------------------------------
set.seed(1234)
model <- scpi(
w.constr = list(name = "lasso"), data = df, u.order = 1, u.lags = 0, u.sigma = "HC1",
u.missp = TRUE, sims = 1000, e.order = 0, e.lags = 1, e.method = "all", cores = parallel::detectCores(),
u.alpha = 0.05, e.alpha = 0.1, rho = NULL, rho.max = 1
)
# Save SCM estimates and inference
scpi_estimates <- sc_est(model, paste0(component, "_res"), period, period.labels)
write_csv(scpi_estimates, paste0("results/FigC2/", output_name, "_scpi_estimates.csv"))
scpi_inference <- sc_inf(model, post_tr = period.post, period_labels = period.labels)
write_csv(scpi_inference, paste0("results/FigC2/", output_name, "_scpi_inference.csv"))
weights <- tibble(
weights = round(model$est.results$w, 4),
country = str_remove(names(model$est.results$w), str_c(unit.tr, "."))
)
write_csv(weights, paste0("results/FigC2/", output_name, "_scpi_weights.csv"))
# ------------------------------------------------------------------------------
# Plotting ATT (Average Treatment Effect) with Prediction Intervals
# ------------------------------------------------------------------------------
# MSE
mse <-
scpi_estimates |>
filter(name == "diff") |>
mutate(
mse = value^2,
)
mse_pre <- (mse |> filter(time_to_treat < 0) |> summarise(mse = sum(mse)))$mse
mse_post <- (mse |> filter(time_to_treat >= 0) |> summarise(mse = sum(mse)))$mse
rmse_pre <- sqrt(mse_pre/(nrow(mse |> filter(time_to_treat < 0)) + 1))
rmse_post <- sqrt(mse_post/(nrow(mse |> filter(time_to_treat >= 0)) + 1))
ratio <- rmse_post/rmse_pre
inference_2 <- scpi_inference |>
filter(time_to_treat != -1) |>
left_join(scpi_estimates |> filter(name == "obs") |> select(time_to_treat, value)) |>
mutate(
lci_ins = value - lci_ins, uci_ins = value - uci_ins,
lci_ofs = value - lci_ofs, uci_ofs = value - uci_ofs
) |>
select(-value)
scpi_estimates |>
filter(name == "diff") |>
ggplot() +
geom_hline(yintercept = 0) +
geom_vline(xintercept = 0) +
scale_x_continuous(breaks = c(seq(-70, 0, 2), seq(0, 4, 2))) +
labs(x = "Relative time to treatment (quarters)", y = "ATT", color = "", fill = "") +
theme(axis.text.x = element_text(size = 8, angle = 0)) +
geom_ribbon(data = inference_2, alpha = 0.25, aes(x = time_to_treat, ymin = lci_ins, ymax = uci_ins, fill = "95% In-sample PI")) +
geom_ribbon(data = inference_2, alpha = 0.5, aes(x = time_to_treat, ymin = lci_ofs, ymax = uci_ofs, fill = "90% Out-of-sample PI")) +
scale_fill_manual(values = c("grey", "grey70")) +
geom_line(aes(time_to_treat, value), color = color4t) +
annotate("label", x = 0, y = Inf, vjust = 0, size = 2, hjust = 1.1, color = "black", label = str_c("RMSPE: ", round(rmse_pre, 3))) +
annotate("label", x = 0, y = Inf, vjust = 0, size = 2, hjust = -0.1, color = "black", label = str_c("RMSPE: ", round(rmse_post, 3))) +
coord_cartesian(clip = "off") +
theme(plot.margin = unit(c(1.25, 1, 1, 1), "lines"))
# Save the plot as a PNG file
ggsave(paste0("results/FigC2/FigC2_", output_name, ".png"), dpi = 300, width = 7.4, height = 4.8)
}
# ------------------------------------------------------------------------------
# ---- Setup: Workspace and Library Loading ----
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# Clear existing workspace
rm(list = ls())
# Ensure pacman is installed
if (!requireNamespace("pacman", quietly = TRUE)) install.packages("pacman")
# Load pacman and required packages
library(pacman)
p_load(
tidyverse,      # Core packages for data manipulation and visualization
readr,          # Read data from text files
janitor,        # Data cleaning
lubridate,      # Date handling
panelView,      # Panel data visualization
fixest,         # Econometric modeling for panel data
countrycode,    # Country code conversion
scpi,           # Synthetic control methods
imputeTS,       # Time series imputation
modelsummary,   # Model summaries and visualizations
readxl,         # Excel file reading
ggnewscale,     # Add multiple scales to ggplot2
ggthemes,       # Additional ggplot2 themes
pracma,         # Practical mathematical functions
tsibble,        # Time series data frame structure
feasts,         # Time series decomposition
fabletools,     # Time series forecasting tools
lpirfs,         # Local projection impulse response functions
zoo,            # Time series objects
binsreg,        # Binned scatterplots for regression analysis
knitr,          # Dynamic report generation in R
httr,           # Tools for working with HTTP, useful for API calls and web requests
readxl          # Read Excel files into R
)
# Install and load GitHub packages
if (!requireNamespace("synthdid", quietly = TRUE)) {
devtools::install_github("synth-inference/synthdid")
}
if (!requireNamespace("vdemdata", quietly = TRUE)) {
devtools::install_github("vdeminstitute/vdemdata")
}
# Load GitHub packages explicitly
library(synthdid)
library(vdemdata)
# Set working directory to the appropriate project path
path <- getwd()
# ---- Plotting Theme
# Define and set a clean theme for all plots using ggthemes and additional customization
theme_clean <-
ggthemes::theme_clean() +
theme(
legend.position = "bottom",
plot.background = element_rect(fill = "white", color = NA), # Set plot background to white
panel.background = element_rect(fill = "white", color = NA), # Set panel background to white
legend.background = element_rect(fill = "white", color = NA), # Set legend background to white
)
theme_set(theme_clean)
# Define a custom color for plotting (used later in your plots)
color4t <- '#a83232'
# ---- Important Dates and Periods
# Key political and event-related dates used for analysis
amlo_vic_date <- ymd("2018-07-01")      # AMLO victory date
amlo_vic_quarter <- 2018.3              # AMLO victory quarter
naim_ref_anouncement <- ymd("2018-08-21")  # Announcement date of NAIM referendum
naim_canc_date <- ymd("2018-10-29")        # NAIM cancelation date
naim_canc_quarter <- 2018.4                # NAIM cancelation quarter
amlo_gov_date <- ymd("2018-12-01")         # AMLO government start date
amlo_gov_quarter <- 2018.4                 # AMLO government start quarter
covid_date <- ymd("2020-02-01")            # Start of COVID-19 pandemic
covid_quarter <- 2020.1                    # COVID-19 quarter
# Set the system locale to English (US) to prevent issues with special characters
Sys.setlocale("LC_ALL", "en_US.UTF-8")
# ---- Load External Functions
# Source custom functions for synthetic control analysis from a separate script
source("scripts/POS_functions.R")
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# ---- Data ----
# ------------------------------------------------------------------------------
# Check "scripts/POS_data.R" to see the construction of derived data from source
source("scripts/POS_data.R")
# ------------------------------------------------------------------------------
# ---- Exhibits ----
run_scm_analysis <- function(component, log_transform = TRUE, output_name) {
# ------------------------------------------------------------------------------
# Data Loading and Preparation
# ------------------------------------------------------------------------------
foo <- posq |>
filter(countrycode %in% c("ARG", "BRA", "CHL", "COL", "CRI", "HND", "ECU", "MEX", "USA", "CAN")) |>
filter(year >= 2013) |>
filter(year_quarter < yearquarter("2020 Q1")) |>
select(countrycode, year_quarter, all_of(component), int_rate, ex_rate, naim) |>  # Selecting component dynamically
distinct() |>
mutate(
across(all_of(component), ~ log(.x)),  # Log-transform component
ex_rate = log(ex_rate),   # Log-transform exchange rate
int_rate = log(int_rate)  # Log-transform interest rate
)
# ------------------------------------------------------------------------------
# Residualization of the component (controlling for interest and exchange rates)
# ------------------------------------------------------------------------------
component_res <- feols(as.formula(paste0(component, " ~ ex_rate + int_rate")), foo)  # Dynamically create formula
foo <- foo |> mutate(!!paste0(component, "_res") := residuals(component_res))  # Store residualized component
# ------------------------------------------------------------------------------
# Defining Pre- and Post-Treatment Periods for SCM
# ------------------------------------------------------------------------------
period.labels <- as.character(levels(factor(foo$year_quarter)))  # Period labels for x-axis
period <- yearquarter(levels(factor(foo$year_quarter)))          # Time variable as year-quarter
time.tr <- yearquarter("2018 Q4")                                # Treatment period (NAIM cancellation)
# Pre-treatment and post-treatment periods
period.pre <- period[-c(match(time.tr, period):length(period))]   # Pre-treatment period
period.post <- period[c(match(time.tr, period):length(period))]   # Post-treatment period
# Add time-to-treatment variable
foo <- foo |>
group_by(countrycode) |>
mutate(
time_to_treat_naim = c(seq(-length(period.pre), -1), seq(0, length(period.post) - 1))  # Relative time to treatment
) |>
ungroup()
period <- as.numeric(levels(factor(foo$time_to_treat_naim)))  # Convert period to numeric
# ------------------------------------------------------------------------------
# Data Preparation for SCM
# ------------------------------------------------------------------------------
# Set options for data preparation
time.tr <- 0
id.var      <- "countrycode"                             # ID variable
time.var    <- "time_to_treat_naim"                                # Time variable
period.pre  <- period[-c(match(time.tr, period):length(period))]   # Pre-treatment period
period.post <- period[c(match(time.tr, period):length(period))]                          # Post-treatment period
unit.tr     <- "MEX"                                      # Treated unit (in terms of id.var)
unit.co     <- unique(foo$countrycode)[-match( "MEX", unique(foo$countrycode))]                    # Donors pool
outcome.var <- paste0(component, "_res")                                 # Outcome variable
cov.adj     <- NULL #list(c("constant"))     # Covariates for adjustment
features    <- NULL #,                                  # No features other than outcome
constant    <- T                                # Constant term
report.missing <- FALSE                              # To check where missing values are
cointegrated.data <- TRUE                            # Belief that the data are cointegrated
w.constr <- list(name = "lasso")     # Simplex-type constraint set
df  <-   scdata(df = foo, id.var = id.var, time.var = time.var, outcome.var = outcome.var,
period.pre = period.pre, period.post = period.post,
unit.tr = unit.tr, unit.co = unit.co, cov.adj = cov.adj, features = features,
constant = constant, cointegrated.data = cointegrated.data)
# ------------------------------------------------------------------------------
# Estimation using SCM
# ------------------------------------------------------------------------------
set.seed(1234)
model <- scpi(
w.constr = list(name = "lasso"), data = df, u.order = 1, u.lags = 0, u.sigma = "HC1",
u.missp = TRUE, sims = 1000, e.order = 0, e.lags = 1, e.method = "all", cores = parallel::detectCores(),
u.alpha = 0.05, e.alpha = 0.1, rho = NULL, rho.max = 1
)
# Save SCM estimates and inference
scpi_estimates <- sc_est(model, paste0(component, "_res"), period, period.labels)
write_csv(scpi_estimates, paste0("results/FigC2/", output_name, "_scpi_estimates.csv"))
scpi_inference <- sc_inf(model, post_tr = period.post, period_labels = period.labels)
write_csv(scpi_inference, paste0("results/FigC2/", output_name, "_scpi_inference.csv"))
weights <- tibble(
weights = round(model$est.results$w, 4),
country = str_remove(names(model$est.results$w), str_c(unit.tr, "."))
)
write_csv(weights, paste0("results/FigC2/", output_name, "_scpi_weights.csv"))
# ------------------------------------------------------------------------------
# Plotting ATT (Average Treatment Effect) with Prediction Intervals
# ------------------------------------------------------------------------------
# MSE
mse <-
scpi_estimates |>
filter(name == "diff") |>
mutate(
mse = value^2,
)
mse_pre <- (mse |> filter(time_to_treat < 0) |> summarise(mse = sum(mse)))$mse
mse_post <- (mse |> filter(time_to_treat >= 0) |> summarise(mse = sum(mse)))$mse
rmse_pre <- sqrt(mse_pre/(nrow(mse |> filter(time_to_treat < 0)) + 1))
rmse_post <- sqrt(mse_post/(nrow(mse |> filter(time_to_treat >= 0)) + 1))
ratio <- rmse_post/rmse_pre
inference_2 <- scpi_inference |>
filter(time_to_treat != -1) |>
left_join(scpi_estimates |> filter(name == "obs") |> select(time_to_treat, value)) |>
mutate(
lci_ins = value - lci_ins, uci_ins = value - uci_ins,
lci_ofs = value - lci_ofs, uci_ofs = value - uci_ofs
) |>
select(-value)
scpi_estimates |>
filter(name == "diff") |>
ggplot() +
geom_hline(yintercept = 0) +
geom_vline(xintercept = 0) +
scale_x_continuous(breaks = c(seq(-70, 0, 2), seq(0, 4, 2))) +
labs(x = "Relative time to treatment (quarters)", y = "ATT", color = "", fill = "") +
theme(axis.text.x = element_text(size = 8, angle = 0)) +
geom_ribbon(data = inference_2, alpha = 0.25, aes(x = time_to_treat, ymin = lci_ins, ymax = uci_ins, fill = "95% In-sample PI")) +
geom_ribbon(data = inference_2, alpha = 0.5, aes(x = time_to_treat, ymin = lci_ofs, ymax = uci_ofs, fill = "90% Out-of-sample PI")) +
scale_fill_manual(values = c("grey", "grey70")) +
geom_line(aes(time_to_treat, value), color = color4t) +
annotate("label", x = 0, y = Inf, vjust = 0, size = 2, hjust = 1.1, color = "black", label = str_c("RMSPE: ", round(rmse_pre, 3))) +
annotate("label", x = 0, y = Inf, vjust = 0, size = 2, hjust = -0.1, color = "black", label = str_c("RMSPE: ", round(rmse_post, 3))) +
coord_cartesian(clip = "off") +
theme(plot.margin = unit(c(1.25, 1, 1, 1), "lines"))
# Save the plot as a PNG file
ggsave(paste0("results/FigC2/FigC2_", output_name, ".png"), dpi = 300, width = 7.4, height = 4.8)
}
# Run SCM for consumption
run_scm_analysis(component = "cnsmpti", output_name = "1consumption")
# Run SCM for government expenditure
run_scm_analysis(component = "govi", output_name = "2government_expenditure")
# Run SCM for exports
run_scm_analysis(component = "exportsi", output_name = "3exports")
# Run SCM for imports
run_scm_analysis(component = "importsi", output_name = "4imports")
